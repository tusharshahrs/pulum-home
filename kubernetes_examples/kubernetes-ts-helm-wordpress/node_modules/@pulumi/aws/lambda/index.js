"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
// Export members:
__export(require("./alias"));
__export(require("./codeSigningConfig"));
__export(require("./eventSourceMapping"));
__export(require("./function"));
__export(require("./functionEventInvokeConfig"));
__export(require("./getAlias"));
__export(require("./getCodeSigningConfig"));
__export(require("./getFunction"));
__export(require("./getInvocation"));
__export(require("./getLayerVersion"));
__export(require("./lambdaMixins"));
__export(require("./layerVersion"));
__export(require("./permission"));
__export(require("./provisionedConcurrencyConfig"));
__export(require("./runtimes"));
// Export enums:
__export(require("../types/enums/lambda"));
// Import resources to register:
const alias_1 = require("./alias");
const codeSigningConfig_1 = require("./codeSigningConfig");
const eventSourceMapping_1 = require("./eventSourceMapping");
const function_1 = require("./function");
const functionEventInvokeConfig_1 = require("./functionEventInvokeConfig");
const layerVersion_1 = require("./layerVersion");
const permission_1 = require("./permission");
const provisionedConcurrencyConfig_1 = require("./provisionedConcurrencyConfig");
const _module = {
    version: utilities.getVersion(),
    construct: (name, type, urn) => {
        switch (type) {
            case "aws:lambda/alias:Alias":
                return new alias_1.Alias(name, undefined, { urn });
            case "aws:lambda/codeSigningConfig:CodeSigningConfig":
                return new codeSigningConfig_1.CodeSigningConfig(name, undefined, { urn });
            case "aws:lambda/eventSourceMapping:EventSourceMapping":
                return new eventSourceMapping_1.EventSourceMapping(name, undefined, { urn });
            case "aws:lambda/function:Function":
                return new function_1.Function(name, undefined, { urn });
            case "aws:lambda/functionEventInvokeConfig:FunctionEventInvokeConfig":
                return new functionEventInvokeConfig_1.FunctionEventInvokeConfig(name, undefined, { urn });
            case "aws:lambda/layerVersion:LayerVersion":
                return new layerVersion_1.LayerVersion(name, undefined, { urn });
            case "aws:lambda/permission:Permission":
                return new permission_1.Permission(name, undefined, { urn });
            case "aws:lambda/provisionedConcurrencyConfig:ProvisionedConcurrencyConfig":
                return new provisionedConcurrencyConfig_1.ProvisionedConcurrencyConfig(name, undefined, { urn });
            default:
                throw new Error(`unknown resource type ${type}`);
        }
    },
};
pulumi.runtime.registerResourceModule("aws", "lambda/alias", _module);
pulumi.runtime.registerResourceModule("aws", "lambda/codeSigningConfig", _module);
pulumi.runtime.registerResourceModule("aws", "lambda/eventSourceMapping", _module);
pulumi.runtime.registerResourceModule("aws", "lambda/function", _module);
pulumi.runtime.registerResourceModule("aws", "lambda/functionEventInvokeConfig", _module);
pulumi.runtime.registerResourceModule("aws", "lambda/layerVersion", _module);
pulumi.runtime.registerResourceModule("aws", "lambda/permission", _module);
pulumi.runtime.registerResourceModule("aws", "lambda/provisionedConcurrencyConfig", _module);
//# sourceMappingURL=index.js.map