"use strict";
// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.VpcCni = void 0;
const pulumi = require("@pulumi/pulumi");
const childProcess = require("child_process");
const crypto = require("crypto");
const fs = require("fs");
const jsyaml = require("js-yaml");
const path = require("path");
const process = require("process");
const tmp = require("tmp");
const which = require("which");
function computeVpcCniYaml(cniYamlText, args) {
    const cniYaml = jsyaml.safeLoadAll(cniYamlText);
    // Rewrite the envvars for the CNI daemon set as per the inputs.
    const daemonSet = cniYaml.filter(o => o.kind === "DaemonSet")[0];
    const env = daemonSet.spec.template.spec.containers[0].env;
    if (args.nodePortSupport) {
        env.push({ name: "AWS_VPC_CNI_NODE_PORT_SUPPORT", value: args.nodePortSupport ? "true" : "false" });
    }
    if (args.customNetworkConfig) {
        env.push({ name: "AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG", value: args.customNetworkConfig ? "true" : "false" });
    }
    if (args.externalSnat) {
        env.push({ name: "AWS_VPC_K8S_CNI_EXTERNALSNAT", value: args.externalSnat ? "true" : "false" });
    }
    if (args.warmEniTarget) {
        env.push({ name: "WARM_ENI_TARGET", value: args.warmEniTarget.toString() });
    }
    if (args.warmIpTarget) {
        env.push({ name: "WARM_IP_TARGET", value: args.warmIpTarget.toString() });
    }
    if (args.logLevel) {
        env.push({ name: "AWS_VPC_K8S_CNI_LOGLEVEL", value: args.logLevel.toString() });
    }
    else {
        env.push({ name: "AWS_VPC_K8S_CNI_LOGLEVEL", value: "DEBUG" });
    }
    if (args.logFile) {
        env.push({ name: "AWS_VPC_K8S_CNI_LOG_FILE", value: args.logFile.toString() });
    }
    else {
        env.push({ name: "AWS_VPC_K8S_CNI_LOG_FILE", value: "stdout" });
    }
    if (args.vethPrefix) {
        env.push({ name: "AWS_VPC_K8S_CNI_VETHPREFIX", value: args.vethPrefix.toString() });
    }
    else {
        env.push({ name: "AWS_VPC_K8S_CNI_VETHPREFIX", value: "eni" });
    }
    if (args.eniMtu) {
        env.push({ name: "AWS_VPC_ENI_MTU", value: args.eniMtu.toString() });
    }
    else {
        env.push({ name: "AWS_VPC_ENI_MTU", value: "9001" });
    }
    if (args.image) {
        daemonSet.spec.template.spec.containers[0].image = args.image.toString();
    }
    if (args.eniConfigLabelDef) {
        env.push({ name: "ENI_CONFIG_LABEL_DEF", value: args.eniConfigLabelDef.toString() });
    }
    // Return the computed YAML.
    return cniYaml.map(o => `---\n${jsyaml.safeDump(o)}`).join("");
}
function applyVpcCniYaml(cniYamlText, args) {
    // Dump the kubeconfig to a file.
    const tmpKubeconfig = tmp.fileSync();
    fs.writeFileSync(tmpKubeconfig.fd, args.kubeconfig);
    // Compute the required CNI YAML and dump it to a file.
    const tmpYaml = tmp.fileSync();
    fs.writeFileSync(tmpYaml.fd, computeVpcCniYaml(cniYamlText, args));
    // Call kubectl to apply the YAML.
    childProcess.execSync(`kubectl apply -f ${tmpYaml.name}`, {
        env: Object.assign(Object.assign({}, process.env), { "KUBECONFIG": tmpKubeconfig.name }),
    });
}
/**
 * VpcCni manages the configuration of the Amazon VPC CNI plugin for Kubernetes by applying its YAML chart. Once Pulumi is
 * able to programatically manage existing infrastructure, we can replace this with a real k8s resource.
 */
class VpcCni extends pulumi.dynamic.Resource {
    constructor(name, kubeconfig, args, opts) {
        // Check to ensure that kubectl is installed, as we'll need it in order to deploy k8s resources below.
        try {
            which.sync("kubectl");
        }
        catch (err) {
            throw new Error("Could not set VPC CNI options: kubectl is missing. See https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl for installation instructions.");
        }
        const yamlPath = path.join(__dirname, "cni", "aws-k8s-cni.yaml");
        const cniYamlText = fs.readFileSync(yamlPath).toString();
        const provider = {
            check: (state, inputs) => Promise.resolve({ inputs: inputs, failedChecks: [] }),
            diff: (id, state, inputs) => Promise.resolve({}),
            create: (inputs) => {
                applyVpcCniYaml(cniYamlText, inputs);
                return Promise.resolve({ id: crypto.randomBytes(8).toString("hex"), outs: {} });
            },
            update: (id, state, inputs) => {
                applyVpcCniYaml(cniYamlText, inputs);
                return Promise.resolve({ outs: {} });
            },
            read: (id, state) => Promise.resolve({ id: id, props: state }),
            delete: (id, state) => Promise.resolve(),
        };
        args = args || {};
        super(provider, name, {
            kubeconfig: pulumi.output(kubeconfig).apply(JSON.stringify),
            nodePortSupport: args.nodePortSupport,
            customNetworkConfig: args.customNetworkConfig,
            externalSnat: args.externalSnat,
            warmEniTarget: args.warmEniTarget,
            warmIpTarget: args.warmIpTarget,
            logLevel: args.logLevel,
            logFile: args.logFile,
            image: args.image,
            eniConfigLabelDef: args.eniConfigLabelDef,
        }, opts);
    }
}
exports.VpcCni = VpcCni;
//# sourceMappingURL=cni.js.map